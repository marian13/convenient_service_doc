"use strict";(self.webpackChunkconvenient_service_docs=self.webpackChunkconvenient_service_docs||[]).push([[5716],{2571:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>t,metadata:()=>c,toc:()=>l});var i=s(4848),r=s(8453);const t={slug:"/best_practices/service_has_only_one_success",sidebar_position:1,title:"Service has only one `success`"},o=void 0,c={id:"best_practices/service_has_only_one_success",title:"Service has only one `success`",description:"Most of the time it is relatively easy to follow this rule.",source:"@site/docs/best_practices/service_has_only_one_success.mdx",sourceDirName:"best_practices",slug:"/best_practices/service_has_only_one_success",permalink:"/best_practices/service_has_only_one_success",draft:!1,unlisted:!1,editUrl:"https://github.com/marian13/convenient_service_docs/blob/main/docs/best_practices/service_has_only_one_success.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{slug:"/best_practices/service_has_only_one_success",sidebar_position:1,title:"Service has only one `success`"},sidebar:"docs",previous:{title:"Avoid error shadowing",permalink:"/best_practices/avoid_error_shadowing"},next:{title:"Services with `or` conditionals",permalink:"/best_practices/services_with_or_conditionals"}},a={},l=[];function d(e){const n={a:"a",code:"code",em:"em",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Most of the time it is relatively easy to follow this rule."}),"\n",(0,i.jsx)(n.p,{children:"Consider the following service:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'class BuildDisplayName\n  include ::ConvenientService::Standard::Config\n\n  attr_reader :person\n\n  def initialize(person:)\n    @person = person\n  end\n\n  def result\n    return error("Person can\'t be blank") if person.blank?\n\n    success(display_name: "#{person.first_name} #{persom.last_name}")\n  end\nend\n'})}),"\n",(0,i.jsxs)(n.p,{children:["It currently has no conditional logic to build the ",(0,i.jsx)(n.code,{children:"display_name"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"After a while, our system started to grow and it appears that some people would like to see their pseudo in place of display names."}),"\n",(0,i.jsx)(n.p,{children:"Let's reflect on that change in the code using a naive approach:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'class BuildDisplayName\n  include ::ConvenientService::Standard::Config\n\n  attr_reader :person\n\n  def initialize(person:)\n    @person = person\n  end\n\n  def result\n    return error("Person can\'t be blank") if person.blank?\n\n    if person.has_pseudonym?\n      success(display_name: person.pseudonym)\n    else\n      success(display_name: "#{person.first_name} #{persom.last_name}")\n    end\n  end\nend\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Having two ",(0,i.jsx)(n.code,{children:"success"})," calls inside the ",(0,i.jsx)(n.code,{children:"result"})," is what we try to avoid."]}),"\n",(0,i.jsx)(n.p,{children:"Why?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["It encourages future devs to write ",(0,i.jsx)(n.a,{href:"https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting",children:"deeply nested conditionals"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["It interferes with the ",(0,i.jsx)(n.a,{href:"https://www.oreilly.com/library/view/universal-principles-of/9781592535873/xhtml/ch67.html",children:"layering of information"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"You don't need to know the details of the implementation until it is really necessary."}),"\n",(0,i.jsx)(n.p,{children:"The code above tells you about pseudonyms too early, even if you are not interested in them."}),"\n",(0,i.jsxs)(n.p,{children:["If you refactor ",(0,i.jsx)(n.code,{children:"BuildDisplayName"})," like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'class BuildDisplayName\n  include ::ConvenientService::Standard::Config\n\n  def initialize(person:)\n    @person = person\n  end\n\n  def result\n    return error("Person can\'t be blank") if person.blank?\n\n    success(display_name: display_name)\n  end\n\n  private\n\n  def display_name\n    @display_name ||= person.has_pseudonym? ? person.pseudonym : "#{person.first_name} #{persom.last_name}"\n  end\nend\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Then the ",(0,i.jsx)(n.code,{children:"result"})," describes which data it may return and when it is NOT successful, just that."]}),"\n",(0,i.jsxs)(n.p,{children:["Only when you are curious about how ",(0,i.jsx)(n.code,{children:"display_name"})," is exactly built, feel free to check private methods."]}),"\n",(0,i.jsxs)(n.p,{children:["This is how the ",(0,i.jsx)(n.a,{href:"https://www.oreilly.com/library/view/universal-principles-of/9781592535873/xhtml/ch67.html",children:"layering of information"})," works in practice."]}),"\n",(0,i.jsxs)(n.p,{children:["Nesting is replaced by a ",(0,i.jsx)(n.a,{href:"https://blog.codinghorror.com/flattening-arrow-code/",children:"flat ternary operator"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"It is time to have a look at the specs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# spec/services/assert_file_exists_spec.rb\nrequire "spec_helper"\n\nRSpec.describe BuildDisplayName do\n  include ConvenientService::RSpec::Matchers::Results\n\n  example_group "class methods" do\n    describe ".result" do\n      let(:result) { described_class.result(person: person) }\n\n      context "when building of display name is NOT successful" do\n        context "when `person` is blank" do\n          let(:person) { nil }\n\n          it "returns `error`" do\n            expect(result).to be_error.with_message("Person can\'t be blank").of_service(described_class).without_step\n          end\n        end\n      end\n\n      context "when building of display name is successful" do\n        context "when `person` does NOT have pseudonym" do\n          let(:person) { Person.new("John", "Doe") }\n\n          it "returns `success` with first name and last name as display name" do\n            expect(result).to be_success.with_data(display_name: "John Doe").of_service(described_class).without_step\n          end\n        end\n\n        context "when `person` has pseudonym" do\n          let(:person) { Person.new("John", "Doe", preudonym: "Gorilla") }\n\n          it "returns `success` with pseudonym as display name" do\n            expect(result).to be_success.with_data(display_name: "Gorilla").of_service(described_class).without_step\n          end\n        end\n      end\n    end\n  end\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, specs still have two contexts for successful cases and that is completely OK."}),"\n",(0,i.jsx)(n.p,{children:"Now, we are ready for the conclusion:"}),"\n",(0,i.jsxs)(n.p,{children:["A fact that a ",(0,i.jsxs)(n.em,{children:["Service has only one ",(0,i.jsx)(n.code,{children:"success"})]})," actually means that the service calls ",(0,i.jsx)(n.code,{children:"success"})," inside ",(0,i.jsx)(n.code,{children:"result"})," only once."]}),"\n",(0,i.jsxs)(n.p,{children:["But that ",(0,i.jsx)(n.code,{children:"success"})," can still have multiple variations of data values, just like ",(0,i.jsx)(n.code,{children:"display_name"})," in ",(0,i.jsx)(n.code,{children:"BuildDisplayName"})," service."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);