"use strict";(self.webpackChunkconvenient_service_docs=self.webpackChunkconvenient_service_docs||[]).push([[4787,8401],{9365:(e,n,t)=>{t.d(n,{A:()=>l});t(6540);var s=t(4164);const i={tabItem:"tabItem_Ymn6"};var r=t(4848);function l(e){let{children:n,hidden:t,className:l}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,s.A)(i.tabItem,l),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>y});var s=t(6540),i=t(4164),r=t(3104),l=t(6347),a=t(205),c=t(7485),o=t(1682),d=t(679);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:i}}=e;return{value:n,label:t,attributes:s,default:i}}))}(t);return function(e){const n=(0,o.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function _(e){let{queryString:n=!1,groupId:t}=e;const i=(0,l.W6)(),r=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(r),(0,s.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(i.location.search);n.set(r,e),i.replace({...i.location,search:n.toString()})}),[r,i])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,r=p(e),[l,c]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:r}))),[o,u]=_({queryString:t,groupId:i}),[f,m]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,r]=(0,d.Dv)(t);return[i,(0,s.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:i}),b=(()=>{const e=o??f;return h({value:e,tabValues:r})?e:null})();(0,a.A)((()=>{b&&c(b)}),[b]);return{selectedValue:l,selectValue:(0,s.useCallback)((e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);c(e),u(e),m(e)}),[u,m,r]),tabValues:r}}var m=t(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=t(4848);function g(e){let{className:n,block:t,selectedValue:s,selectValue:l,tabValues:a}=e;const c=[],{blockElementScrollPositionUntilNextRender:o}=(0,r.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),i=a[t].value;i!==s&&(o(n),l(i))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},n),children:a.map((e=>{let{value:n,label:t,attributes:r}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>c.push(e),onKeyDown:u,onClick:d,...r,className:(0,i.A)("tabs__item",b.tabItem,r?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function x(e){let{lazy:n,children:t,selectedValue:r}=e;const l=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=l.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:l.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function w(e){const n=f(e);return(0,v.jsxs)("div",{className:(0,i.A)("tabs-container",b.tabList),children:[(0,v.jsx)(g,{...n,...e}),(0,v.jsx)(x,{...n,...e})]})}function y(e){const n=(0,m.A)();return(0,v.jsx)(w,{...e,children:u(e.children)},String(n))}},6005:(e,n,t)=>{t.r(n),t.d(n,{default:()=>c});t(6540);var s=t(3660),i=t(1470),r=t(9365),l=t(4428),a=t(4848);function c(){return(0,a.jsxs)(s.A,{children:[(0,a.jsx)(l.A,{language:"ruby",children:'\n          # Any source code in the project.\n          def read_file_content(path)\n            result = ReadFileContent.result(path: path)\n            -\n            if result.success?\n              ##\n              # Service tried to read the file content and completed it.\n              #\n              result.data[:content] # File content.\n            elsif result.failure?\n              ##\n              # Service tried to read file content but did NOT complete it due to some expected reason.\n              #\n              App.logger.warn { result.message.to_s }\n              -\n              "" # Fallback value or any other reasonable fallback behavior.\n            else # result.error?\n              ##\n              # Service NOT even tried to read file content due to a validation issue or exception.\n              #\n              App.logger.error { result.message.to_s }\n              -\n              raise VerboseException, result.message.to_s # Self-explanatory exception or any other reasonable fallback behavior.\n            end\n          end\n        '}),(0,a.jsxs)(i.A,{groupId:"config",children:[(0,a.jsx)(r.A,{value:"standard",label:"Standard",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # config/initializers/convenient_service.rb\n              require "convenient_service"\n            '})}),(0,a.jsx)(r.A,{value:"rails",label:"Rails",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # config/initializers/convenient_service.rb\n              require "active_model" # NOTE: Minimal `active_model` version - `5.2.0`.\n              -\n              require "convenient_service"\n              -\n              ConvenientService::Dependencies.require_assigns_attributes_in_constructor_using_active_model_attribute_assignment\n              ConvenientService::Dependencies.require_has_attributes_using_active_model_attributes\n              ConvenientService::Dependencies.require_has_result_params_validations_using_active_model_validations\n            '})}),(0,a.jsx)(r.A,{value:"dry",label:"Dry",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # config/initializers/convenient_service.rb\n              require "dry-initializer" # NOTE: Minimal `dry-initializer` version - `3.0.0`.\n              require "dry-validation" # NOTE: Minimal `dry-validation` version - `1.5.0`.\n              -\n              require "convenient_service"\n              -\n              ConvenientService::Dependencies.require_assigns_attributes_in_constructor_using_dry_initializer\n              ConvenientService::Dependencies.require_has_result_params_validations_using_dry_validation\n            '})})]}),(0,a.jsxs)(i.A,{groupId:"config",children:[(0,a.jsx)(r.A,{value:"standard",label:"Standard",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:"\n              # app/services/application_service/config.rb\n              module ApplicationService\n                module Config\n                  include ConvenientService::Concern\n                  -\n                  included do\n                    include ConvenientService::Standard::Config\n                  end\n                end\n              end\n            "})}),(0,a.jsx)(r.A,{value:"rails",label:"Rails",children:(0,a.jsx)(l.A,{language:"ruby",children:"\n              # app/services/rails_service/config.rb\n              module RailsService\n                module Config\n                  include ConvenientService::Concern\n                  -\n                  included do\n                    include ConvenientService::Standard::Config\n                    -\n                    concerns do\n                      use ConvenientService::Plugins::Common::AssignsAttributesInConstructor::UsingActiveModelAttributeAssignment::Concern\n                      use ConvenientService::Plugins::Common::HasAttributes::UsingActiveModelAttributes::Concern\n                      use ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Concern\n                    end\n                    -\n                    middlewares :initialize do\n                      use ConvenientService::Plugins::Common::AssignsAttributesInConstructor::UsingActiveModelAttributeAssignment::Middleware\n                    end\n                    -\n                    middlewares :result do\n                      insert_before \\\n                        ConvenientService::Plugins::Service::CanHaveSteps::Middleware,\n                        ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Middleware\n                    end\n                  end\n                end\n              end\n            "})}),(0,a.jsx)(r.A,{value:"dry",label:"Dry",children:(0,a.jsx)(l.A,{language:"ruby",children:"\n              # app/services/dry_service/config.rb\n              module DryService\n                module Config\n                  include ConvenientService::Concern\n                  -\n                  included do\n                    include ConvenientService::Standard::Config\n                    -\n                    concerns do\n                      use ConvenientService::Plugins::Common::AssignsAttributesInConstructor::UsingDryInitializer::Concern\n                      use ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingDryValidation::Concern\n                    end\n                    -\n                    middlewares :result do\n                      insert_before \\\n                        ConvenientService::Plugins::Service::CanHaveSteps::Middleware,\n                        ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingDryValidation::Middleware\n                    end\n                  end\n                end\n              end\n            "})})]}),(0,a.jsxs)(i.A,{groupId:"config",children:[(0,a.jsx)(r.A,{value:"standard",label:"Standard",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # app/services/assert_file_exist.rb\n              class AssertFileExists\n                include ApplicationService::Config\n                -\n                attr_reader :path\n                -\n                def initialize(path:)\n                  @path = path\n                end\n                -\n                def result\n                  return error("Path is `nil`") if path.nil?\n                  return error("Path is empty") if path.empty?\n                  -\n                  return failure("File does not exist at path `#{path}`") unless ::File.exist?(path)\n                  -\n                  success\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"rails",label:"Rails",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # app/services/assert_file_exist.rb\n              class AssertFileExists\n                include RailsService::Config\n                -\n                attribute :path, :string\n                -\n                validates :path, presence: true\n                -\n                def result\n                  return failure("File does not exist at path `#{path}`") unless ::File.exist?(path)\n                  -\n                  success\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"dry",label:"Dry",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # app/services/assert_file_exist.rb\n              class AssertFileExists\n                include DryService::Config\n                -\n                option :path\n                -\n                contract do\n                  schema do\n                    required(:path).value(:string)\n                  end\n                end\n                -\n                def result\n                  return failure("File does not exist at path `#{path}`") unless ::File.exist?(path)\n                  -\n                  success\n                end\n              end\n            '})})]}),(0,a.jsx)(l.A,{language:"ruby",children:'result = AssertFileExists.result(path: "Gemfile")'}),(0,a.jsxs)(i.A,{groupId:"config",children:[(0,a.jsx)(r.A,{value:"standard",label:"Standard",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/assert_file_exists_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileExists do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(ApplicationService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file exists is NOT successful" do\n                      context "when `path` is NOT valid" do\n                        context "when `path` is `nil`" do\n                          let(:path) { nil }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is `nil`").of_service(described_class).without_step\n                          end\n                        end\n                        -\n                        context "when `path` is empty" do\n                          let(:path) { "" }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is empty").of_service(described_class).without_step\n                          end\n                        end\n                      end\n                      -\n                      context "when file with `path` does NOT exist" do\n                        let(:path) { "non_existing_path" }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"rails",label:"Rails",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/assert_file_exists_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileExists do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(RailsService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file exists is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("can\'t be blank").of_service(described_class).without_step\n                        end\n                      end\n                      -\n                      context "when file with `path` does NOT exist" do\n                        let(:path) { "non_existing_path" }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.without_data.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"dry",label:"Dry",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/assert_file_exists_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileExists do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(DryService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file exists is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("must be filled").of_service(described_class).without_step\n                        end\n                      end\n                      -\n                      context "when file with `path` does NOT exist" do\n                        let(:path) { "non_existing_path" }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.without_data.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            '})})]}),(0,a.jsx)(l.A,{language:"bash",children:"bundle exec rspec spec/services/assert_file_exits_spec.rb"}),(0,a.jsxs)(i.A,{groupId:"config",children:[(0,a.jsx)(r.A,{value:"standard",label:"Standard",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # app/services/assert_file_not_empty.rb\n              class AssertFileNotEmpty\n                include ApplicationService::Config\n                -\n                attr_accessor :path\n                -\n                def initialize(path:)\n                  @path = path\n                end\n                -\n                def result\n                  return error("Path is `nil`") if path.nil?\n                  return error("Path is empty") if path.empty?\n                  -\n                  return failure("File is empty at path `#{path}`") if ::File.zero?(path)\n                  -\n                  success\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"rails",label:"Rails",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # app/services/assert_file_not_empty.rb\n              class AssertFileNotEmpty\n                include RailsService::Config\n                -\n                attribute :path, :string\n                -\n                validates :path, presence: true\n                -\n                def result\n                  return failure("File is empty at path `#{path}`") if ::File.zero?(path)\n                  -\n                  success\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"dry",label:"Dry",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # app/services/assert_file_not_empty.rb\n              class AssertFileNotEmpty\n                include DryService::Config\n                -\n                option :path\n                -\n                contract do\n                  schema do\n                    required(:path).value(:string)\n                  end\n                end\n                -\n                def result\n                  return failure("File is empty at path `#{path}`") if ::File.zero?(path)\n                  -\n                  success\n                end\n              end\n            '})})]}),(0,a.jsx)(l.A,{language:"ruby",children:'result = AssertFileNotEmpty.result(path: "Gemfile")'}),(0,a.jsxs)(i.A,{groupId:"config",children:[(0,a.jsx)(r.A,{value:"standard",label:"Standard",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/assert_file_not_empty_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileNotEmpty do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(ApplicationService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      context "when `path` is NOT valid" do\n                        context "when `path` is `nil`" do\n                          let(:path) { nil }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is `nil`").of_service(described_class).without_step\n                          end\n                        end\n                        -\n                        context "when `path` is empty" do\n                          let(:path) { "" }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is empty").of_service(described_class).without_step\n                          end\n                        end\n                      end\n                      -\n                      context "when file is empty" do\n                        ##\n                        # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                        #\n                        let(:tempfile) { Tempfile.new }\n                        let(:path) { tempfile.path }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` is empty").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new.tap { |file| file.write("content") }.tap(&:close) }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"rails",label:"Rails",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/assert_file_not_empty_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileNotEmpty do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(RailsService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("can\'t be blank").of_service(described_class).without_step\n                        end\n                      end\n                      -\n                      context "when file is empty" do\n                        ##\n                        # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                        #\n                        let(:tempfile) { Tempfile.new }\n                        let(:path) { tempfile.path }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` is empty").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new.tap { |file| file.write("content") }.tap(&:close) }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.without_data.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"dry",label:"Dry",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/assert_file_not_empty_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileNotEmpty do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(DryService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("must be filled").of_service(described_class).without_step\n                        end\n                      end\n                      -\n                      context "when file is empty" do\n                        ##\n                        # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                        #\n                        let(:tempfile) { Tempfile.new }\n                        let(:path) { tempfile.path }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` is empty").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new.tap { |file| file.write("content") }.tap(&:close) }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.without_data.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            '})})]}),(0,a.jsx)(l.A,{language:"bash",children:"bundle exec rspec spec/services/assert_file_not_empty_spec.rb"}),(0,a.jsxs)(i.A,{groupId:"config",children:[(0,a.jsx)(r.A,{value:"standard",label:"Standard",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # app/services/read_file_content.rb\n              class ReadFileContent\n                include ApplicationService::Config\n                -\n                attr_reader :path\n                -\n                step :validate_path\n                step AssertFileExists, in: :path\n                step AssertFileNotEmpty, in: :path\n                step :result, in: :path, out: :content\n                -\n                def initialize(path:)\n                  @path = path\n                end\n                -\n                def result\n                  success(content: ::File.read(path))\n                end\n                -\n                private\n                -\n                def validate_path\n                  return error("Path is `nil`") if path.nil?\n                  return error("Path is empty") if path.empty?\n                  -\n                  success\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"rails",label:"Rails",children:(0,a.jsx)(l.A,{language:"ruby",children:"\n              # app/services/read_file_content.rb\n              class ReadFileContent\n                include RailsService::Config\n                -\n                attribute :path, :string\n                -\n                validates :path, presence: true\n                -\n                step AssertFileExists, in: :path\n                step AssertFileNotEmpty, in: :path\n                step :result, in: :path, out: :content\n                -\n                def result\n                  success(content: ::File.read(path))\n                end\n              end\n            "})}),(0,a.jsx)(r.A,{value:"dry",label:"Dry",children:(0,a.jsx)(l.A,{language:"ruby",children:"\n              # app/services/read_file_content.rb\n              class ReadFileContent\n                include DryService::Config\n                -\n                option :path\n                -\n                contract do\n                  schema do\n                    required(:path).value(:string)\n                  end\n                end\n                -\n                step AssertFileExists, in: :path\n                step AssertFileNotEmpty, in: :path\n                step :result, in: :path, out: :content\n                -\n                def result\n                  success(content: ::File.read(path))\n                end\n              end\n            "})})]}),(0,a.jsx)(l.A,{language:"ruby",children:'\n          result = ReadFileContent.result(path: "Gemfile")\n          -\n          if result.success?\n            result.data[:content]\n          else\n            result.message\n          end\n        '}),(0,a.jsxs)(i.A,{groupId:"config",children:[(0,a.jsx)(r.A,{value:"standard",label:"Standard",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/read_file_content.rb\n              require "spec_helper"\n              -\n              RSpec.describe ReadFileContent do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(ApplicationService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when reading file content is NOT successful" do\n                      context "when `path` is NOT valid" do\n                        context "when `path` is `nil`" do\n                          let(:path) { nil }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is `nil`").of_service(described_class).of_step(:validate_path)\n                          end\n                        end\n                        -\n                        context "when `path` is empty" do\n                          let(:path) { "" }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is empty").of_service(described_class).of_step(:validate_path)\n                          end\n                        end\n                      end\n                      -\n                      context "when assertion that file exists is NOT successful" do\n                        let(:path) { "not_existing_path" }\n                        -\n                        it "returns intermediate step result" do\n                          expect(result).to be_not_success.of_service(described_class).of_step(AssertFileExists)\n                        end\n                      end\n                      -\n                      context "when assertion that file is NOT empty is NOT successful" do\n                        let(:temfile) { Tempfile.new }\n                        let(:path) { temfile.path }\n                        -\n                        it "returns intermediate step result" do\n                          expect(result).to be_not_success.of_service(described_class).of_step(AssertFileNotEmpty)\n                        end\n                      end\n                    end\n                    -\n                    context "when reading file content is successful" do\n                      let(:temfile) { Tempfile.new.tap { |tempfile| tempfile.write(content) }.tap(&:close) }\n                      let(:path) { temfile.path }\n                      let(:content) { "some content" }\n                      -\n                      it "returns `success` with content" do\n                        expect(result).to be_success.with_data(content: content).of_service(described_class).of_step(:result)\n                      end\n                    end\n                  end\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"rails",label:"Rails",children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/read_file_content.rb\n              require "spec_helper"\n              -\n              RSpec.describe ReadFileContent do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(RailsService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when reading file content is NOT successful" do\n                      context "when path is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("can\'t be blank").without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is NOT successful" do\n                      let(:path) { "not_existing_path" }\n                      -\n                      it "returns intermediate step result" do\n                        expect(result).to be_not_success.of_service(described_class).of_step(AssertFileExists)\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      let(:temfile) { Tempfile.new }\n                      let(:path) { temfile.path }\n                      -\n                      it "returns intermediate step result" do\n                        expect(result).to be_not_success.of_service(described_class).of_step(AssertFileNotEmpty)\n                      end\n                    end\n                  end\n                  -\n                  context "when reading file content is successful" do\n                    let(:temfile) { Tempfile.new.tap { |tempfile| tempfile.write(content) }.tap(&:close) }\n                    let(:path) { temfile.path }\n                    let(:content) { "some content" }\n                    -\n                    it "returns `success` with content" do\n                      expect(result).to be_success.with_data(content: content).of_service(described_class).of_step(:result)\n                    end\n                  end\n                end\n              end\n            '})}),(0,a.jsx)(r.A,{value:"dry",label:"Dry",default:!0,children:(0,a.jsx)(l.A,{language:"ruby",children:'\n              # spec/services/read_file_content.rb\n              require "spec_helper"\n              -\n              RSpec.describe ReadFileContent do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(DryService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when reading file content is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("must be filled").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is NOT successful" do\n                      let(:path) { "not_existing_path" }\n                      -\n                      it "returns intermediate step result" do\n                        expect(result).to be_not_success.of_service(described_class).of_step(AssertFileExists)\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      let(:temfile) { Tempfile.new }\n                      let(:path) { temfile.path }\n                      -\n                      it "returns intermediate step result" do\n                        expect(result).to be_not_success.of_service(described_class).of_step(AssertFileNotEmpty)\n                      end\n                    end\n                  end\n                  -\n                  context "when reading file content is successful" do\n                    let(:temfile) { Tempfile.new.tap { |tempfile| tempfile.write(content) }.tap(&:close) }\n                    let(:path) { temfile.path }\n                    let(:content) { "some content" }\n                    -\n                    it "returns `success` with content" do\n                      expect(result).to be_success.with_data(content: content).of_service(described_class).of_step(:result)\n                    end\n                  end\n                end\n              end\n            '})})]}),(0,a.jsx)(l.A,{language:"bash",children:"bundle exec rspec spec/services/read_file_content_spec.rb"})]})}},4428:(e,n,t)=>{t.d(n,{A:()=>l});t(6540);var s=t(1432),i=t(4848);const r=e=>{let n=e.toString().split("\n");n=""===n[0]?n.slice(1):n;const t=n.find((e=>e.length)).search(/[^ ]/),s=-1===t?0:t;return n.map((e=>e.trimEnd())).map((e=>"-"===e.trimStart()?"":e)).map((e=>e.slice(s))).join("\n")};function l(e){let{children:n,...t}=e;return(0,i.jsx)(i.Fragment,{children:(0,i.jsx)(s.A,{...t,children:r(n)})})}}}]);