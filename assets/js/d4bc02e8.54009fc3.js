"use strict";(self.webpackChunkconvenient_service_docs=self.webpackChunkconvenient_service_docs||[]).push([[6729],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=l(t),m=i,_=d["".concat(c,".").concat(m)]||d[m]||u[m]||a;return t?r.createElement(_,s(s({ref:n},p),{},{components:t})):r.createElement(_,s({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,s=new Array(a);s[0]=d;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var l=2;l<a;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9494:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=t(7462),i=(t(7294),t(3905));const a={slug:"/best_practices/services_with_or_conditionals",sidebar_position:3,title:"Services with `or` conditionals"},s=void 0,o={unversionedId:"best_practices/services_with_or_conditionals",id:"best_practices/services_with_or_conditionals",title:"Services with `or` conditionals",description:"Convenient Service shines very brightly when you have and conditional logic.",source:"@site/docs/best_practices/services_with_or_conditionals.mdx",sourceDirName:"best_practices",slug:"/best_practices/services_with_or_conditionals",permalink:"/convenient_service_docs/best_practices/services_with_or_conditionals",draft:!1,editUrl:"https://github.com/marian13/convenient_service_docs/blob/main/docs/best_practices/services_with_or_conditionals.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{slug:"/best_practices/services_with_or_conditionals",sidebar_position:3,title:"Services with `or` conditionals"},sidebar:"docs",previous:{title:"Service has only one `success`",permalink:"/convenient_service_docs/best_practices/service_has_only_one_success"},next:{title:"Glossary",permalink:"/convenient_service_docs/category/glossary"}},c={},l=[],p={toc:l};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/"},"Convenient Service")," shines very brightly when you have ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," conditional logic."),(0,i.kt)("p",null,"It is very easy to construct such behavior using the ",(0,i.kt)("inlineCode",{parentName:"p"},"step")," DSL."),(0,i.kt)("p",null,"Check out the following service:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"class RefreshSubscription\n  include ::ConvenientService::Standard::Config\n\n  attr_reader :user, :subscription_id\n\n  step IsSubscriptionOwner,\n    in: [:user, :subscription_id]\n\n  step FindSubscription,\n    in: :subscription_id,\n    out: :subscription\n\n  step RegenerateSubscriptionTokens\n    in: :subscription,\n    out: :tokens\n\n  step UploadSubscriptionTokens\n    in: :subscription,\n    out: :tokens\n\n  def initialize(:user, :subscription_id)\n    @user = user\n    @subscription_id = subscription_id\n  end\nend\n")),(0,i.kt)("p",null,"Let's use the pseudo notation below to describe a sequence of steps from ",(0,i.kt)("inlineCode",{parentName:"p"},"RefreshSubscription")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," conditionals:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"`IsSubscriptionOwner`\n  and `FindSubscription`\n  and `RegenerateSubscriptionTokens`\n  and `UploadSubscriptionTokens`.\n")),(0,i.kt)("p",null,"Pretty simple and straightforward."),(0,i.kt)("p",null,"But, but, but \ud83d\ude22..."),(0,i.kt)("p",null,"What should we do when we have some ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," conditionals?"),(0,i.kt)("p",null,"For example, two additional requirements are introduced to the one we had before:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Super admin can refresh any user subscriptions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A user with a special ability can refresh other user's subscriptions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"User can refresh its own subscription (already existing requirement)."))),(0,i.kt)("p",null,"In our pseudo notation it will look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"`IsSuperAdmin` or `HasAbility`or `IsSubscriptionOwner`\n  and `FindSubscription`\n  and `RegenerateSubscriptionTokens`\n  and `UploadSubscriptionTokens`\n")),(0,i.kt)("p",null,"It is not the time to give up \ud83d\ude2d."),(0,i.kt)("p",null,"The list of to-do actions is not so long:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a new service which name generalizes all ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," conditions, for instance - ",(0,i.kt)("inlineCode",{parentName:"p"},"IsAuthorizedForSubscriptionRefresh"),"."),(0,i.kt)("p",{parentName:"li"},"Then the updated pseudo notation can be displayed as:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"`IsAuthorizedForSubscriptionRefresh`\n  and `FindSubscription`\n  and `RegenerateSubscriptionTokens`\n  and `UploadSubscriptionTokens`\n")),(0,i.kt)("p",{parentName:"li"},"Now, we can utilize all the ",(0,i.kt)("a",{parentName:"p",href:"/basics/step_to_result_translation_table"},(0,i.kt)("inlineCode",{parentName:"a"},"step")," DSL")," s usual."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"class RefreshSubscription\n  # ...\n\n  step IsAuthorizedForSubscriptionRefresh,\n    in: [:user, :subscription_id]\n\n  step FindSubscription,\n    in: :subscription_id,\n    out: :subscription\n\n  step RegenerateSubscriptionTokens\n    in: :subscription,\n    out: :tokens\n\n  step UploadSubscriptionTokens\n    in: :subscription,\n    out: :tokens\n\n  # ...\nend\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Prepare a common template for a service with ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," conditionals."),(0,i.kt)("p",{parentName:"li"},"Here it is for our particular case:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"class IsAuthorizedForSubscriptionRefresh\n  include ::ConvenientService::Standard::Config\n\n  attr_reader :user, :subscription_id\n\n  def initialize(:user, :subscription_id)\n    @user = user\n    @subscription_id = subscription_id\n  end\n\n  def result\n    # TODO: Implement\n  end\n\n  private\n\n  def is_super_admin_result\n    @is_super_admin_result ||= IsSuperAdmin.result(user: user)\n  end\n\n  def has_ability_result\n    @has_ability_result ||= HasAbility.result(user: user, ability: :refresh_someone_else_subscription)\n  end\n\n  def is_subscription_owner_result\n    @is_subscription_owner_result ||= IsSubscriptionOwner.result(user: user, subscription_id: subscription_id)\n  end\nend\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"result")," method."),(0,i.kt)("p",{parentName:"li"},"Before we move on to the final polished chuck of code, let's discuss the common anti-patterns."),(0,i.kt)("p",{parentName:"li"},"Please, welcome ",(0,i.kt)("a",{parentName:"p",href:"https://lawyerdev.medium.com/i-never-write-nested-ifs-e4e91a5440ee"},"deeply nested if statements")," and ",(0,i.kt)("a",{parentName:"p",href:"/best_practices/service_has_only_one_success"},"multiple success calls"),"."),(0,i.kt)("h3",{parentName:"li",id:"zombie-version-"},"Zombie version \ud83e\udddf"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},'# bad - zombie\ndef result\n  if is_super_admin_result.not_success?\n    if has_ability_result.not_success?\n      if is_subscription_owner_result.not_success?\n        error(\n          "All conditions are not satisfied:"\n            + " "\n            + is_super_admin_result.message\n            + " "\n            + has_ability_result.message\n            + " "\n            + is_subscription_owner_result.message\n        )\n      else\n        success\n      end\n    else\n      success\n    end\n  else\n    success\n  end\nend\n')),(0,i.kt)("p",{parentName:"li"},'Although, this code is "perfect" from the performance point of view and it works exactly as needed according to the requirements...'),(0,i.kt)("p",{parentName:"li"},"Please, do not commit it."),(0,i.kt)("p",{parentName:"li"},"Just imagine what will happen with an additional fourth or fifth condition."),(0,i.kt)("p",{parentName:"li"},"How can we make it simpler and more readable?"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/best_practices/service_has_only_one_success"},"Call ",(0,i.kt)("inlineCode",{parentName:"a"},"success")," only once"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://ruby-doc.org/core-2.7.0/Enumerable.html"},"Leverage Ruby collections"),"."))),(0,i.kt)("h3",{parentName:"li",id:"array-version"},"Array version"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},'# better - array, but it preloads all conditions even when they are not used\ndef result\n  if conditions.all?(&:not_success?)\n    return error("All conditions are not satisfied: " + conditions.map(&:message).join(" "))\n  end\n\n  success\nend\n\nprivate\n\ndef conditions\n  @conditions ||= [\n    is_super_admin_result,\n    has_ability_result,\n    is_subscription_owner_result\n  ]\nend\n')),(0,i.kt)("p",{parentName:"li"},"As you can see, it removes ",(0,i.kt)("a",{parentName:"p",href:"https://lawyerdev.medium.com/i-never-write-nested-ifs-e4e91a5440ee"},"deeply nested if statements")," completely."),(0,i.kt)("p",{parentName:"li"},"Also it allows to use ",(0,i.kt)("a",{parentName:"p",href:"/best_practices/service_has_only_one_success"},"only one success"),"."),(0,i.kt)("p",{parentName:"li"},"The array version is a lot better than what we had before, but it still has one hidden problem that is not obvious."),(0,i.kt)("p",{parentName:"li"},"When you create an array, its elements are immediately calculated, no matter whether you access them later or not."),(0,i.kt)("p",{parentName:"li"},"If we make an assumption that a user has the ability to refresh someone else subscription, then we don't need to check whether that user is the subscription owner at all."),(0,i.kt)("p",{parentName:"li"},"This extra verification can become a huge issue if it is resource-heavy like a long-running SQL query or low-responding HTTP request."),(0,i.kt)("p",{parentName:"li"},"Luckily, Ruby has a ",(0,i.kt)("a",{parentName:"p",href:"https://ruby-doc.org/core-2.7.0/Enumerator.html"},"build-in class")," that has the array-like interface, but with lazy elements calculation."),(0,i.kt)("h3",{parentName:"li",id:"enumerator-version"},"Enumerator version:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},'# very good - enumerator, simple code and lazy calculation\ndef result\n  if conditions.all?(&:not_success?)\n    return error("All conditions are not satisfied: " + conditions.map(&:message).join(" "))\n  end\n\n  success\nend\n\nprivate\n\ndef conditions\n  @conditions ||= ::Enumerator.new do |collection|\n    collection << is_super_admin_result\n    collection << has_ability_result\n    collection << is_subscription_owner_result\n  end\nend\n')),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://ruby-doc.org/core-2.7.0/Enumerator.html"},"Enumerator")," is a duck for ",(0,i.kt)("a",{parentName:"p",href:"https://ruby-doc.org/core-2.7.0/Array.html"},"Array")," most of the time, since both of them include the ",(0,i.kt)("a",{parentName:"p",href:"https://ruby-doc.org/core-2.7.0/Enumerable.html"},"Enumerable")," module."),(0,i.kt)("p",{parentName:"li"},"But the crucial moment is that ",(0,i.kt)("a",{parentName:"p",href:"https://ruby-doc.org/core-2.7.0/Enumerator.html"},"Enumerator")," may lazily calculate its elements when used properly."),(0,i.kt)("h3",{parentName:"li",id:"pattern"},"Pattern"),(0,i.kt)("p",{parentName:"li"},"The final full version will quickly become a pattern in your codebase."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},'class IsAuthorizedForSubscriptionRefresh\n  include ::ConvenientService::Standard::Config\n\n  attr_reader :user, :subscription_id\n\n  def initialize(:user, :subscription_id)\n    @user = user\n    @subscription_id = subscription_id\n  end\n\n  def result\n    if conditions.all?(&:not_success?)\n      return error("All conditions are not satisfied: " + conditions.map(&:message).join(" "))\n    end\n\n    success\n  end\n\n  private\n\n  def conditions\n    @conditions ||= ::Enumerator.new do |collection|\n      collection << is_super_admin_result\n      collection << has_ability_result\n      collection << is_subscription_owner_result\n    end\n  end\n\n  def is_super_admin_result\n    @is_super_admin_result ||= IsSuperAdmin.result(user: user)\n  end\n\n  def has_ability_result\n    @has_ability_result ||= HasAbility.result(user: user, ability: :refresh_someone_else_subscription)\n  end\n\n  def is_subscription_owner_result\n    @is_subscription_owner_result ||= IsSubscriptionOwner.result(user: user, subscription_id: subscription_id)\n  end\nend\n')),(0,i.kt)("p",{parentName:"li"},"In order to add a new ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," condition just create a new memoized method with a result and push it into the ",(0,i.kt)("a",{parentName:"p",href:"https://ruby-doc.org/core-2.7.0/Enumerator.html"},"Enumerator")," collection."),(0,i.kt)("admonition",{parentName:"li",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Convenient Service authors highly encourage the usage of the pattern from this article since it will be abstracted away in one of the future releases by a new DSL macro like ",(0,i.kt)("inlineCode",{parentName:"p"},"step"),"."),(0,i.kt)("p",{parentName:"admonition"},"This way you will have all the preconditions met for minimal refactoring.")),(0,i.kt)("h3",{parentName:"li",id:"extended-pattern"},"Extended pattern"),(0,i.kt)("p",{parentName:"li"},"It is also very common to have services with ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," conditions for ",(0,i.kt)("a",{parentName:"p",href:"https://refactoring.guru/design-patterns/factory-method"},"factory methods"),"."),(0,i.kt)("p",{parentName:"li"},"In such a scenario original pattern is extended by hashes."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},'class CreateButton\n  include ::ConvenientService::Standard::Config\n\n  attr_reader :app\n\n  def initialize(:app)\n    @app = app\n  end\n\n  def result\n    if factories.all? { |factory| factory[:result].not_success? }\n      return error("All factories are not satisfied: " + factories.map { |factory| factory[:result].message }.join(" "))\n    end\n\n    success(button: factories.find { |factory| factory[:result].success? }.values_at(:result, :data_key).then { |result, key| result.data[key] })\n  end\n\n  private\n\n  def factories\n    @factories ||= ::Enumerator.new do |collection|\n      collection << create_web_button_factory\n      collection << create_android_button_factory\n      collection << create_ios_button_factory\n      collection << create_desktop_button_factory\n    end\n  end\n\n  def create_web_button_factory\n    @create_web_button_factory ||= {\n      result: CreateWebButtonFactory.result(app: app),\n      data_key: :button\n    }\n  end\n\n  def create_android_button_factory\n    @create_android_button_factory ||= {\n      result: CreateAndroidButtonFactory.result(app: app),\n      data_key: :action\n    }\n  end\n\n  def create_ios_button_factory\n    @create_ios_button_factory ||= {\n      result: CreateIosButtonFactory.result(app: app),\n      data_key: :control\n    }\n  end\n\n  def create_desktop_button_factory\n    @create_desktop_button_factory ||= {\n      result: CreateDesktopButtonFactory.result(app: app),\n      data_key: :knob\n    }\n  end\nend\n')))))}u.isMDXComponent=!0}}]);