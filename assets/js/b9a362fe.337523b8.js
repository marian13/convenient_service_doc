"use strict";(self.webpackChunkconvenient_service_docs=self.webpackChunkconvenient_service_docs||[]).push([[9496,7918],{5162:(e,n,t)=>{t.d(n,{Z:()=>l});var s=t(7294),i=t(6010);const r="tabItem_Ymn6";function l(e){let{children:n,hidden:t,className:l}=e;return s.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,l),hidden:t},n)}},5488:(e,n,t)=>{t.d(n,{Z:()=>h});var s=t(7462),i=t(7294),r=t(6010),l=t(2389),a=t(7392),c=t(7094),o=t(2466);const d="tabList__CuJ",u="tabItem_LNqP";function p(e){var n;const{lazy:t,block:l,defaultValue:p,values:h,groupId:m,className:_}=e,f=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),v=h??f.map((e=>{let{props:{value:n,label:t,attributes:s}}=e;return{value:n,label:t,attributes:s}})),b=(0,a.l)(v,((e,n)=>e.value===n.value));if(b.length>0)throw new Error(`Docusaurus error: Duplicate values "${b.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===p?p:p??(null==(n=f.find((e=>e.props.default)))?void 0:n.props.value)??f[0].props.value;if(null!==g&&!v.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${v.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:w,setTabGroupChoices:x}=(0,c.U)(),[y,E]=(0,i.useState)(g),S=[],{blockElementScrollPositionUntilNextRender:C}=(0,o.o5)();if(null!=m){const e=w[m];null!=e&&e!==y&&v.some((n=>n.value===e))&&E(e)}const T=e=>{const n=e.currentTarget,t=S.indexOf(n),s=v[t].value;s!==y&&(C(n),E(s),null!=m&&x(m,String(s)))},N=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=S.indexOf(e.currentTarget)+1;t=S[n]??S[0];break}case"ArrowLeft":{const n=S.indexOf(e.currentTarget)-1;t=S[n]??S[S.length-1];break}}null==(n=t)||n.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",d)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":l},_)},v.map((e=>{let{value:n,label:t,attributes:l}=e;return i.createElement("li",(0,s.Z)({role:"tab",tabIndex:y===n?0:-1,"aria-selected":y===n,key:n,ref:e=>S.push(e),onKeyDown:N,onFocus:T,onClick:T},l,{className:(0,r.Z)("tabs__item",u,null==l?void 0:l.className,{"tabs__item--active":y===n})}),t??n)}))),t?(0,i.cloneElement)(f.filter((e=>e.props.value===y))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},f.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==y})))))}function h(e){const n=(0,l.Z)();return i.createElement(p,(0,s.Z)({key:String(n)},e))}},3019:(e,n,t)=>{t.r(n),t.d(n,{default:()=>c});var s=t(7294),i=t(6791),r=t(5488),l=t(5162),a=t(8573);function c(){return s.createElement(i.Z,null,s.createElement(a.Z,{language:"ruby"},'\n          # Any source code in the project.\n          def read_file_content(path)\n            result = ReadFileContent.result(path: path)\n            -\n            if result.success?\n              ##\n              # Service tried to read the file content and completed it.\n              #\n              result.data[:content] # File content.\n            elsif result.failure?\n              ##\n              # Service tried to read file content but did NOT complete it due to some expected reason.\n              #\n              App.logger.warn { result.message.to_s }\n              -\n              "" # Fallback value or any other reasonable fallback behavior.\n            else # result.error?\n              ##\n              # Service NOT even tried to read file content due to a validation issue or exception.\n              #\n              App.logger.error { result.message.to_s }\n              -\n              raise VerboseException, result.message.to_s # Self-explanatory exception or any other reasonable fallback behavior.\n            end\n          end\n        '),s.createElement(r.Z,{groupId:"config"},s.createElement(l.Z,{value:"standard",label:"Standard",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # config/initializers/convenient_service.rb\n              require "convenient_service"\n            ')),s.createElement(l.Z,{value:"rails",label:"Rails"},s.createElement(a.Z,{language:"ruby"},'\n              # config/initializers/convenient_service.rb\n              require "active_model" # NOTE: Minimal `active_model` version - `5.2.0`.\n              -\n              require "convenient_service"\n              -\n              ConvenientService::Dependencies.require_assigns_attributes_in_constructor_using_active_model_attribute_assignment\n              ConvenientService::Dependencies.require_has_attributes_using_active_model_attributes\n              ConvenientService::Dependencies.require_has_result_params_validations_using_active_model_validations\n            ')),s.createElement(l.Z,{value:"dry",label:"Dry"},s.createElement(a.Z,{language:"ruby"},'\n              # config/initializers/convenient_service.rb\n              require "dry-initializer" # NOTE: Minimal `dry-initializer` version - `3.0.0`.\n              require "dry-validation" # NOTE: Minimal `dry-validation` version - `1.5.0`.\n              -\n              require "convenient_service"\n              -\n              ConvenientService::Dependencies.require_assigns_attributes_in_constructor_using_dry_initializer\n              ConvenientService::Dependencies.require_has_result_params_validations_using_dry_validation\n            '))),s.createElement(r.Z,{groupId:"config"},s.createElement(l.Z,{value:"standard",label:"Standard",default:!0},s.createElement(a.Z,{language:"ruby"},"\n              # app/services/application_service/config.rb\n              module ApplicationService\n                module Config\n                  include ConvenientService::Concern\n                  -\n                  included do\n                    include ConvenientService::Standard::Config\n                  end\n                end\n              end\n            ")),s.createElement(l.Z,{value:"rails",label:"Rails"},s.createElement(a.Z,{language:"ruby"},"\n              # app/services/rails_service/config.rb\n              module RailsService\n                module Config\n                  include ConvenientService::Concern\n                  -\n                  included do\n                    include ConvenientService::Standard::Config\n                    -\n                    concerns do\n                      use ConvenientService::Plugins::Common::AssignsAttributesInConstructor::UsingActiveModelAttributeAssignment::Concern\n                      use ConvenientService::Plugins::Common::HasAttributes::UsingActiveModelAttributes::Concern\n                      use ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Concern\n                    end\n                    -\n                    middlewares :initialize do\n                      use ConvenientService::Plugins::Common::AssignsAttributesInConstructor::UsingActiveModelAttributeAssignment::Middleware\n                    end\n                    -\n                    middlewares :result do\n                      insert_before \\\n                        ConvenientService::Plugins::Service::CanHaveSteps::Middleware,\n                        ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Middleware\n                    end\n                  end\n                end\n              end\n            ")),s.createElement(l.Z,{value:"dry",label:"Dry"},s.createElement(a.Z,{language:"ruby"},"\n              # app/services/dry_service/config.rb\n              module DryService\n                module Config\n                  include ConvenientService::Concern\n                  -\n                  included do\n                    include ConvenientService::Standard::Config\n                    -\n                    concerns do\n                      use ConvenientService::Plugins::Common::AssignsAttributesInConstructor::UsingDryInitializer::Concern\n                      use ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingDryValidation::Concern\n                    end\n                    -\n                    middlewares :result do\n                      insert_before \\\n                        ConvenientService::Plugins::Service::CanHaveSteps::Middleware,\n                        ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingDryValidation::Middleware\n                    end\n                  end\n                end\n              end\n            "))),s.createElement(r.Z,{groupId:"config"},s.createElement(l.Z,{value:"standard",label:"Standard",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # app/services/assert_file_exist.rb\n              class AssertFileExists\n                include ApplicationService::Config\n                -\n                attr_reader :path\n                -\n                def initialize(path:)\n                  @path = path\n                end\n                -\n                def result\n                  return error("Path is `nil`") if path.nil?\n                  return error("Path is empty") if path.empty?\n                  -\n                  return failure("File does not exist at path `#{path}`") unless ::File.exist?(path)\n                  -\n                  success\n                end\n              end\n            ')),s.createElement(l.Z,{value:"rails",label:"Rails"},s.createElement(a.Z,{language:"ruby"},'\n              # app/services/assert_file_exist.rb\n              class AssertFileExists\n                include RailsService::Config\n                -\n                attribute :path, :string\n                -\n                validates :path, presence: true\n                -\n                def result\n                  return failure("File does not exist at path `#{path}`") unless ::File.exist?(path)\n                  -\n                  success\n                end\n              end\n            ')),s.createElement(l.Z,{value:"dry",label:"Dry"},s.createElement(a.Z,{language:"ruby"},'\n              # app/services/assert_file_exist.rb\n              class AssertFileExists\n                include DryService::Config\n                -\n                option :path\n                -\n                contract do\n                  schema do\n                    required(:path).value(:string)\n                  end\n                end\n                -\n                def result\n                  return failure("File does not exist at path `#{path}`") unless ::File.exist?(path)\n                  -\n                  success\n                end\n              end\n            '))),s.createElement(a.Z,{language:"ruby"},'result = AssertFileExists.result(path: "Gemfile")'),s.createElement(r.Z,{groupId:"config"},s.createElement(l.Z,{value:"standard",label:"Standard",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/assert_file_exists_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileExists do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(ApplicationService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file exists is NOT successful" do\n                      context "when `path` is NOT valid" do\n                        context "when `path` is `nil`" do\n                          let(:path) { nil }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is `nil`").of_service(described_class).without_step\n                          end\n                        end\n                        -\n                        context "when `path` is empty" do\n                          let(:path) { "" }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is empty").of_service(described_class).without_step\n                          end\n                        end\n                      end\n                      -\n                      context "when file with `path` does NOT exist" do\n                        let(:path) { "non_existing_path" }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            ')),s.createElement(l.Z,{value:"rails",label:"Rails",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/assert_file_exists_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileExists do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(RailsService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file exists is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("can\'t be blank").of_service(described_class).without_step\n                        end\n                      end\n                      -\n                      context "when file with `path` does NOT exist" do\n                        let(:path) { "non_existing_path" }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.without_data.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            ')),s.createElement(l.Z,{value:"dry",label:"Dry"},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/assert_file_exists_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileExists do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(DryService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file exists is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("must be filled").of_service(described_class).without_step\n                        end\n                      end\n                      -\n                      context "when file with `path` does NOT exist" do\n                        let(:path) { "non_existing_path" }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.without_data.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            '))),s.createElement(a.Z,{language:"bash"},"bundle exec rspec spec/services/assert_file_exits_spec.rb"),s.createElement(r.Z,{groupId:"config"},s.createElement(l.Z,{value:"standard",label:"Standard",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # app/services/assert_file_not_empty.rb\n              class AssertFileNotEmpty\n                include ApplicationService::Config\n                -\n                attr_accessor :path\n                -\n                def initialize(path:)\n                  @path = path\n                end\n                -\n                def result\n                  return error("Path is `nil`") if path.nil?\n                  return error("Path is empty") if path.empty?\n                  -\n                  return failure("File is empty at path `#{path}`") if ::File.zero?(path)\n                  -\n                  success\n                end\n              end\n            ')),s.createElement(l.Z,{value:"rails",label:"Rails"},s.createElement(a.Z,{language:"ruby"},'\n              # app/services/assert_file_not_empty.rb\n              class AssertFileNotEmpty\n                include RailsService::Config\n                -\n                attribute :path, :string\n                -\n                validates :path, presence: true\n                -\n                def result\n                  return failure("File is empty at path `#{path}`") if ::File.zero?(path)\n                  -\n                  success\n                end\n              end\n            ')),s.createElement(l.Z,{value:"dry",label:"Dry"},s.createElement(a.Z,{language:"ruby"},'\n              # app/services/assert_file_not_empty.rb\n              class AssertFileNotEmpty\n                include DryService::Config\n                -\n                option :path\n                -\n                contract do\n                  schema do\n                    required(:path).value(:string)\n                  end\n                end\n                -\n                def result\n                  return failure("File is empty at path `#{path}`") if ::File.zero?(path)\n                  -\n                  success\n                end\n              end\n            '))),s.createElement(a.Z,{language:"ruby"},'result = AssertFileNotEmpty.result(path: "Gemfile")'),s.createElement(r.Z,{groupId:"config"},s.createElement(l.Z,{value:"standard",label:"Standard",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/assert_file_not_empty_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileNotEmpty do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(ApplicationService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      context "when `path` is NOT valid" do\n                        context "when `path` is `nil`" do\n                          let(:path) { nil }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is `nil`").of_service(described_class).without_step\n                          end\n                        end\n                        -\n                        context "when `path` is empty" do\n                          let(:path) { "" }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is empty").of_service(described_class).without_step\n                          end\n                        end\n                      end\n                      -\n                      context "when file is empty" do\n                        ##\n                        # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                        #\n                        let(:tempfile) { Tempfile.new }\n                        let(:path) { tempfile.path }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` is empty").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new.tap { |file| file.write("content") }.tap(&:close) }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            ')),s.createElement(l.Z,{value:"rails",label:"Rails"},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/assert_file_not_empty_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileNotEmpty do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(RailsService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("can\'t be blank").of_service(described_class).without_step\n                        end\n                      end\n                      -\n                      context "when file is empty" do\n                        ##\n                        # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                        #\n                        let(:tempfile) { Tempfile.new }\n                        let(:path) { tempfile.path }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` is empty").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new.tap { |file| file.write("content") }.tap(&:close) }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.without_data.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            ')),s.createElement(l.Z,{value:"dry",label:"Dry",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/assert_file_not_empty_spec.rb\n              require "spec_helper"\n              -\n              RSpec.describe AssertFileNotEmpty do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(DryService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("must be filled").of_service(described_class).without_step\n                        end\n                      end\n                      -\n                      context "when file is empty" do\n                        ##\n                        # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                        #\n                        let(:tempfile) { Tempfile.new }\n                        let(:path) { tempfile.path }\n                        -\n                        it "returns `failure` with `message`" do\n                          expect(result).to be_failure.with_message("File with path `#{path}` is empty").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is successful" do\n                      ##\n                      # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n                      #\n                      let(:tempfile) { Tempfile.new.tap { |file| file.write("content") }.tap(&:close) }\n                      let(:path) { tempfile.path }\n                      -\n                      it "returns `success`" do\n                        expect(result).to be_success.without_data.of_service(described_class).without_step\n                      end\n                    end\n                  end\n                end\n              end\n            '))),s.createElement(a.Z,{language:"bash"},"bundle exec rspec spec/services/assert_file_not_empty_spec.rb"),s.createElement(r.Z,{groupId:"config"},s.createElement(l.Z,{value:"standard",label:"Standard",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # app/services/read_file_content.rb\n              class ReadFileContent\n                include ApplicationService::Config\n                -\n                attr_reader :path\n                -\n                step :validate_path\n                step AssertFileExists, in: :path\n                step AssertFileNotEmpty, in: :path\n                step :result, in: :path, out: :content\n                -\n                def initialize(path:)\n                  @path = path\n                end\n                -\n                def result\n                  success(content: ::File.read(path))\n                end\n                -\n                private\n                -\n                def validate_path\n                  return error("Path is `nil`") if path.nil?\n                  return error("Path is empty") if path.empty?\n                  -\n                  success\n                end\n              end\n            ')),s.createElement(l.Z,{value:"rails",label:"Rails"},s.createElement(a.Z,{language:"ruby"},"\n              # app/services/read_file_content.rb\n              class ReadFileContent\n                include RailsService::Config\n                -\n                attribute :path, :string\n                -\n                validates :path, presence: true\n                -\n                step AssertFileExists, in: :path\n                step AssertFileNotEmpty, in: :path\n                step :result, in: :path, out: :content\n                -\n                def result\n                  success(content: ::File.read(path))\n                end\n              end\n            ")),s.createElement(l.Z,{value:"dry",label:"Dry"},s.createElement(a.Z,{language:"ruby"},"\n              # app/services/read_file_content.rb\n              class ReadFileContent\n                include DryService::Config\n                -\n                option :path\n                -\n                contract do\n                  schema do\n                    required(:path).value(:string)\n                  end\n                end\n                -\n                step AssertFileExists, in: :path\n                step AssertFileNotEmpty, in: :path\n                step :result, in: :path, out: :content\n                -\n                def result\n                  success(content: ::File.read(path))\n                end\n              end\n            "))),s.createElement(a.Z,{language:"ruby"},'\n          result = ReadFileContent.result(path: "Gemfile")\n          -\n          if result.success?\n            result.data[:content]\n          else\n            result.message\n          end\n        '),s.createElement(r.Z,{groupId:"config"},s.createElement(l.Z,{value:"standard",label:"Standard",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/read_file_content.rb\n              require "spec_helper"\n              -\n              RSpec.describe ReadFileContent do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(ApplicationService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when reading file content is NOT successful" do\n                      context "when `path` is NOT valid" do\n                        context "when `path` is `nil`" do\n                          let(:path) { nil }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is `nil`").of_service(described_class).of_step(:validate_path)\n                          end\n                        end\n                        -\n                        context "when `path` is empty" do\n                          let(:path) { "" }\n                          -\n                          it "returns `error` with `message`" do\n                            expect(result).to be_error.with_message("Path is empty").of_service(described_class).of_step(:validate_path)\n                          end\n                        end\n                      end\n                      -\n                      context "when assertion that file exists is NOT successful" do\n                        let(:path) { "not_existing_path" }\n                        -\n                        it "returns intermediate step result" do\n                          expect(result).to be_not_success.of_service(described_class).of_step(AssertFileExists)\n                        end\n                      end\n                      -\n                      context "when assertion that file is NOT empty is NOT successful" do\n                        let(:temfile) { Tempfile.new }\n                        let(:path) { temfile.path }\n                        -\n                        it "returns intermediate step result" do\n                          expect(result).to be_not_success.of_service(described_class).of_step(AssertFileNotEmpty)\n                        end\n                      end\n                    end\n                    -\n                    context "when reading file content is successful" do\n                      let(:temfile) { Tempfile.new.tap { |tempfile| tempfile.write(content) }.tap(&:close) }\n                      let(:path) { temfile.path }\n                      let(:content) { "some content" }\n                      -\n                      it "returns `success` with content" do\n                        expect(result).to be_success.with_data(content: content).of_service(described_class).of_step(:result)\n                      end\n                    end\n                  end\n                end\n              end\n            ')),s.createElement(l.Z,{value:"rails",label:"Rails"},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/read_file_content.rb\n              require "spec_helper"\n              -\n              RSpec.describe ReadFileContent do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(RailsService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when reading file content is NOT successful" do\n                      context "when path is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("can\'t be blank").without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is NOT successful" do\n                      let(:path) { "not_existing_path" }\n                      -\n                      it "returns intermediate step result" do\n                        expect(result).to be_not_success.of_service(described_class).of_step(AssertFileExists)\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      let(:temfile) { Tempfile.new }\n                      let(:path) { temfile.path }\n                      -\n                      it "returns intermediate step result" do\n                        expect(result).to be_not_success.of_service(described_class).of_step(AssertFileNotEmpty)\n                      end\n                    end\n                  end\n                  -\n                  context "when reading file content is successful" do\n                    let(:temfile) { Tempfile.new.tap { |tempfile| tempfile.write(content) }.tap(&:close) }\n                    let(:path) { temfile.path }\n                    let(:content) { "some content" }\n                    -\n                    it "returns `success` with content" do\n                      expect(result).to be_success.with_data(content: content).of_service(described_class).of_step(:result)\n                    end\n                  end\n                end\n              end\n            ')),s.createElement(l.Z,{value:"dry",label:"Dry",default:!0},s.createElement(a.Z,{language:"ruby"},'\n              # spec/services/read_file_content.rb\n              require "spec_helper"\n              -\n              RSpec.describe ReadFileContent do\n                include ConvenientService::RSpec::Matchers::Results\n                include ConvenientService::RSpec::Matchers::IncludeModule\n                -\n                let(:result) { described_class.result(path: path) }\n                -\n                example_group "modules" do\n                  subject { described_class }\n                  -\n                  it { is_expected.to include_module(DryService::Config) }\n                end\n                -\n                example_group "class methods" do\n                  describe ".result" do\n                    context "when reading file content is NOT successful" do\n                      context "when `path` is NOT present" do\n                        let(:path) { "" }\n                        -\n                        it "returns `error` with `message`" do\n                          expect(result).to be_error.with_message("must be filled").of_service(described_class).without_step\n                        end\n                      end\n                    end\n                    -\n                    context "when assertion that file exists is NOT successful" do\n                      let(:path) { "not_existing_path" }\n                      -\n                      it "returns intermediate step result" do\n                        expect(result).to be_not_success.of_service(described_class).of_step(AssertFileExists)\n                      end\n                    end\n                    -\n                    context "when assertion that file is NOT empty is NOT successful" do\n                      let(:temfile) { Tempfile.new }\n                      let(:path) { temfile.path }\n                      -\n                      it "returns intermediate step result" do\n                        expect(result).to be_not_success.of_service(described_class).of_step(AssertFileNotEmpty)\n                      end\n                    end\n                  end\n                  -\n                  context "when reading file content is successful" do\n                    let(:temfile) { Tempfile.new.tap { |tempfile| tempfile.write(content) }.tap(&:close) }\n                    let(:path) { temfile.path }\n                    let(:content) { "some content" }\n                    -\n                    it "returns `success` with content" do\n                      expect(result).to be_success.with_data(content: content).of_service(described_class).of_step(:result)\n                    end\n                  end\n                end\n              end\n            '))),s.createElement(a.Z,{language:"bash"},"bundle exec rspec spec/services/read_file_content_spec.rb"))}},8573:(e,n,t)=>{t.d(n,{Z:()=>l});var s=t(7410),i=t(7294),r=t(814);(void 0!==t.g?t.g:window).Prism=s.Z,t(9385),t(6512);function l(e){let{children:n,...t}=e;return i.createElement(i.Fragment,null,i.createElement(r.Z,t,(e=>{let n=e.toString().split("\n");n=""===n[0]?n.slice(1):n;const t=n.find((e=>e.length)).search(/[^ ]/),s=-1===t?0:t;return n.map((e=>e.trimEnd())).map((e=>"-"===e.trimStart()?"":e)).map((e=>e.slice(s))).join("\n")})(n)))}}}]);