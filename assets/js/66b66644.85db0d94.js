"use strict";(self.webpackChunkconvenient_service_docs=self.webpackChunkconvenient_service_docs||[]).push([[5515],{1263:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var s=t(4848),r=t(8453);const i={slug:"/guides/advanced/deprecations/how_to_migrate_from_standard_v1",sidebar_position:1,title:"How to migrate from `Standard::V1`?"},a=void 0,d={id:"guides/advanced/deprecations/how_to_migrate_from_standard_v1",title:"How to migrate from `Standard::V1`?",description:"Consider the following old service that is using the outdated ConvenientService::Config.",source:"@site/docs/guides/advanced/deprecations/how_to_migrate_from_standard_v1.mdx",sourceDirName:"guides/advanced/deprecations",slug:"/guides/advanced/deprecations/how_to_migrate_from_standard_v1",permalink:"/guides/advanced/deprecations/how_to_migrate_from_standard_v1",draft:!1,unlisted:!1,editUrl:"https://github.com/marian13/convenient_service_docs/blob/main/docs/guides/advanced/deprecations/how_to_migrate_from_standard_v1.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{slug:"/guides/advanced/deprecations/how_to_migrate_from_standard_v1",sidebar_position:1,title:"How to migrate from `Standard::V1`?"},sidebar:"docs",previous:{title:"Deprecations",permalink:"/category/deprecations"},next:{title:"API",permalink:"/category/api"}},o={},c=[];function l(e){const n={a:"a",admonition:"admonition",code:"code",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Consider the following old service that is using the outdated ",(0,s.jsx)(n.a,{href:"/glossary/advanced/standard_v1",children:"ConvenientService::Standard::V1::Config"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'class AssertFileNotEmpty\n  include ConvenientService::Standard::V1::Config\n\n  attr_reader :path\n\n  def initialize(path:)\n    @path = path\n  end\n\n  def result\n    return failure(path: "Path is \\`nil\\`") if path.nil?\n    return failure(path: "Path is empty") if path.empty?\n\n    return error("File is empty at path \\`#{path}\\`") if ::File.zero?(path)\n\n    success\n  end\nend\n'})}),"\n",(0,s.jsx)(n.p,{children:"Its specs may look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'require "spec_helper"\n\nRSpec.describe AssertFileExists do\n  include ConvenientService::RSpec::Matchers::Results\n  include ConvenientService::RSpec::Matchers::IncludeModule\n\n  let(:result) { described_class.result(path: path) }\n\n  example_group "modules" do\n    subject { described_class }\n\n    it { is_expected.to include_module(ApplicationService::Config) }\n  end\n\n  example_group "class methods" do\n    describe ".result" do\n      context "when assertion that file exists is NOT successful" do\n        context "when `path` is NOT valid" do\n          context "when `path` is `nil`" do\n            let(:path) { nil }\n\n            it "returns `failure` with `data`" do\n              expect(result).to be_failure.with_data(path: "Path is `nil`").of_service(described_class).without_step\n            end\n          end\n\n          context "when `path` is empty" do\n            let(:path) { "" }\n\n            it "returns `failure` with `data`" do\n              expect(result).to be_failure.with_data(path: "Path is empty").of_service(described_class).without_step\n            end\n          end\n        end\n\n        context "when file with `path` does NOT exist" do\n          let(:path) { "non_existing_path" }\n\n          it "returns `error` with `message`" do\n            expect(result).to be_error.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n          end\n        end\n      end\n\n      context "when assertion that file exists is successful" do\n        ##\n        # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection.\n        #\n        let(:tempfile) { Tempfile.new }\n        let(:path) { tempfile.path }\n\n        it "returns `success`" do\n          expect(result).to be_success.of_service(described_class).without_step\n        end\n      end\n    end\n  end\nend\n'})}),"\n",(0,s.jsx)(n.p,{children:"In order to migrate it, we need to perform four actions:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Rename the outdated configuration to the modern one."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"class AssertFileNotEmpty\n  # before\n  include ConvenientService::Standard::V1::Config\n\n  # after\n  include ConvenientService::Standard::Config\n\n  # ...\nend\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["Rename ",(0,s.jsx)(n.code,{children:"failures"})," and ",(0,s.jsx)(n.code,{children:"errors"})," results inside the source code."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'class AssertFileNotEmpty\n  # ...\n\n  # before\n  def result\n    return failure(path: "Path is \\`nil\\`") if path.nil?\n    return failure(path: "Path is empty") if path.empty?\n\n    return error("File is empty at path \\`#{path}\\`") if ::File.zero?(path)\n\n    success\n  end\n\n  # after\n  def result\n    return error("Path is \\`nil\\`") if path.nil?\n    return error("Path is empty") if path.empty?\n\n    return failure("File is empty at path \\`#{path}\\`") if ::File.zero?(path)\n\n    success\n  end\nend\n'})}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsx)(n.p,{children:'This update should NOT be "blind".'}),(0,s.jsxs)(n.p,{children:["Make sure ",(0,s.jsx)(n.code,{children:"failures"})," and ",(0,s.jsx)(n.code,{children:"errors"})," are used according to their meanings."]})]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["Rename ",(0,s.jsx)(n.code,{children:"failures"})," and ",(0,s.jsx)(n.code,{children:"errors"})," results inside the specs."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'require "spec_helper"\n\nRSpec.describe AssertFileExists do\n  # ...\n\n  # before\n  it "returns `failure` with `data`" do\n    expect(result).to be_failure.with_data(path: "Path is `nil`").of_service(described_class).without_step\n  end\n\n  # after\n  it "returns `error` with `message`" do\n    expect(result).to be_error.with_message("Path is `nil`").of_service(described_class).without_step\n  end\n\n  # before\n  it "returns `failure` with `data`" do\n    expect(result).to be_failure.with_data(path: "Path is empty").of_service(described_class).without_step\n  end\n\n  # after\n  it "returns `error` with `message`" do\n    expect(result).to be_error.with_message("Path is empty").of_service(described_class).without_step\n  end\n\n  # before\n  it "returns `error` with `message`" do\n    expect(result).to be_error.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n  end\n\n  # after\n  it "returns `failure` with `message`" do\n    expect(result).to be_failure.with_message("File with path `#{path}` does NOT exist").of_service(described_class).without_step\n  end\n\n  # ...\nend\n'})}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsxs)(n.p,{children:["Again, please, ensure that ",(0,s.jsx)(n.code,{children:"failures"})," and ",(0,s.jsx)(n.code,{children:"errors"})," are used according to their meanings."]}),(0,s.jsx)(n.p,{children:"Otherwise, this renaming makes no sense."})]}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:["Repeat the same procedure for the rest services that are using ",(0,s.jsx)(n.a,{href:"/glossary/advanced/standard_v1",children:"ConvenientService::Standard::V1::Config"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"danger",children:[(0,s.jsx)(n.p,{children:"Do not mix services with the modern and outdated configurations."}),(0,s.jsx)(n.p,{children:"For example, that is possible with steps."}),(0,s.jsx)(n.p,{children:"Instead, update all outdated services at once or delay this refactoring for the better times."}),(0,s.jsx)(n.p,{children:"If you structure your services as isolated features, then refactor the whole feature."})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>d});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);