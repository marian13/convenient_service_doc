---
slug: /guides/usage/how_to_use_steps
sidebar_position: 3
title: How to use service steps?
---

## Which types of steps are available?

The two criteria currently categorize steps.

- By action: service and method steps.

- By control flow: `and`, `or`, `not` steps.

## How to define a service step?

You can register existing services as steps of other services using the `step` directive.

Let's have a look at it in practice.

Having the `Service` service.

```ruby
class Service
  include ConvenientService::Standard::Config

  def result
    success
  end
end
```

We can use it as a step of the `OtherService` service in the following way.

```ruby
class OtherService
  include ConvenientService::Standard::Config

  step Service
end
```

This code works almost the same as:

```ruby
class OtherService
  include ConvenientService::Standard::Config

  def result
    Service.result
  end
end
```

That is why for a single-step service the usage of steps may not seem very beneficial.

So consider a more complex example.

Now we have 3 services.

```ruby
class FooService
  include ConvenientService::Standard::Config

  def result
    success
  end
end
```

```ruby
class BarService
  include ConvenientService::Standard::Config

  def result
    success
  end
end
```

```ruby
class BazService
  include ConvenientService::Standard::Config

  def result
    success
  end
end
```

The `HostService` uses them as steps.

```ruby
class HostService
  include ConvenientService::Standard::Config

  step FooService
  step BarService
  step BazService
end
```

Rough `HostService` equivalent without steps may be implemented as follows:

```ruby
class HostService
  include ConvenientService::Standard::Config

  def result
    foo_result = FooService.result

    return foo_result unless foo_result.success?

    bar_result = BarService.result

    return bar_result unless bar_result.success?

    BazService.result
  end
end
```

As you can see, steps allow us to eliminate at least 2 assignments and 2 if-conditionals for this particular example.

Sure, those assignments and if-conditionals are still performed under the hood, but it is no longer a developer's responsibility to manage them.

Now the benefit of steps becomes more obvious, but that is not the only benefit.

Other guides are going to demonstrate the additional simplifications.

## How to define a method step?

Any method can be a step.

The only requirement is that it must return a result.

For example:

```ruby
class Service
  include ConvenientService::Standard::Config

  step :foo

  def foo
    success
  end
end
```

## What is the result of a service with steps?

Consider the following service.

```ruby
class Service
  include ConvenientService::Standard::Config

  step :foo
  step :bar
  step :baz

  def foo
    success
  end

  def bar
    success
  end

  def baz
    success
  end
end
```

When all steps are successful, the overall service result is the last step result.

```ruby
result = Service.result
# => <Service::Result status: :success>
```

```ruby
result.step
# => <Service::Step method: :baz>
```

Let's check some other service.

```ruby
class OtherService
  include ConvenientService::Standard::Config

  step :foo
  step :bar
  step :baz

  def foo
    success
  end

  def bar
    failure("Message from `bar`") # `error("Message from `bar`")` also stops the sequence.
  end

  def baz
    raise "Not raised exception"

    success
  end
end
```

When any step is NOT successful, the overall service result is that NOT successful step result.

```ruby
result = OtherService.result
# => <OtherService::Result status: :failure>
```

```ruby
result.step
# => <OtherService::Step method: :bar>
```

It is important to note that the remaining steps are NOT even evaluated.

That is why the exception from `baz` was not raised.

## What is an organizer?

*Organizer* is a service with steps.

It is also worth mentioning that services without steps are often referred to as *regular services*.

## How to pass arguments to steps?

Use the `in` option of the `step` directive.

Here is a quick example.

The `NestedService` accepts two keyword arguments - `:first_kwarg`, and `:second_kwarg`.

```ruby
class NestedService
  include ConvenientService::Standard::Config

  attr_reader :first_kwarg, :second_kwarg

  def initialize(:first_kwarg, :second_kwarg)
    @first_kwarg = first_kwarg
    @second_kwarg = second_kwarg
  end

  def result
    puts "first_kwarg: `#{first_kwarg}`"
    puts "second_kwarg: `#{second_kwarg}`"

    success
  end
end
```

This is how the `in` option is utilized in order to pass them as step inputs.

```ruby
class Service
  include ConvenientService::Standard::Config

  step NestedService, in: [:first_kwarg, :second_kwarg]

  def first_kwarg
    :foo
  end

  def second_kwarg
    :bar
  end
end
```

As you can see below, the corresponding methods' return values are passed as `:first_kwarg` and `:second_kwarg` to the `NestedService` step when we call the organizer.

For this particular case, it is `:foo` and `:bar` respectively.

```ruby
result = Service.result
# => "first_kwarg: `:foo`"
# => "second_kwarg: `:bar`"
# => <Service::Result status: :success>
```

In order to simplify the understanding of the step inputs, let's have a closer look at this specific line.

```ruby
step NestedService, in: [:first_kwarg, :second_kwarg]
```

Whenever you have trouble with its meaning, please, remember that it can be always [mentally translated](/basics/step_to_result_translation_table) like so:

```ruby
def first_step_result
  @first_step_result ||= NestedService.result(
    first_kwarg: first_kwarg,
    second_kwarg: second_kwarg
  )
end
```

That is why it is important to have corresponding instance methods defined for step inputs in the organizer class.

More examples of the `in` usage may be found in [the so-called translation table](/basics/step_to_result_translation_table).
